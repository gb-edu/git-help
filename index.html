<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  <title>Git --help</title>
</head>
<body>
  <header class="header">
    <div class="container">
      <div class="header__inner">
        <img src="assets/img/logo.png" alt="logo">
        <div><span>git</span> --fast-help</div>
      </div>
    </div>
  </header>
  <div class="container">
    <div class="content">
      <div class="column">
        <h2>Установка Git</h2>
        <h3>Обновление Git на Ubuntu</h3>
        <pre class="code">
$ sudo add-apt-repository -y ppa:git-core/ppa
$ sudo apt-get update
$ sudo apt-get install git -y</pre>
        
        <h3>Текущая версия Git</h3>
        <pre class="code">$ git --version</pre>
        <h3>Установка на Linux</h3>
        <p class="text">Установить Git на Linux как бинарный пакет можно
        используя обычный менеджер пакетов дистрибутива.
        Если у вас Fedora (RHEL или CentOS), можно воспользоваться dnf:</p>
        <pre class="code">$ sudo dnf install git-all</pre>
        <p class="text">Если дистрибутив, основанный на Debian, например, Ubuntu, попробуйте apt:</p>
        <pre class="code">$ sudo apt install git</pre>
        <p class="text">Инструкция по установке:
        <a class="link" href="https://git-scm.com/download/linux">git-scm.com/download/linux</a></p>
        
        <h3>Установка в Windows</h3>
        <p class="text">
        <a href="https://git-scm.com/download/win" class="link">git-scm.com/download/win</a>
        </p>
        <p class="text">Обратите внимание, что это отдельный проект, называемый Git для Windows.
        Дополнительная информации на <a href="https://gitforwindows.org" class="link">gitforwindows.org</a>.
        </p>
        <h2>Начальная настройка Git</h2>
        <h3>Список настроек</h3>
        <pre class="code">$ git config --list</pre>
        <p class="text">Проверить значение конкретного ключа:</p>
        <pre class="code">git config [key]</pre>
        <pre class="code">
$ git config user.name
John Doe</pre>
        <h3>Имя пользователя</h3>
        <pre class="code">
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com</pre>
      
        <h3>Выбор редактора</h3>
        <pre class="code">$ git config --global core.editor emacs</pre>
        <p class="text">Команды <span class="intext">git config core.editor</span>
        <a class="link" href="https://git-scm.com/book/ru/v2/ch00/r_core_editor">git-scm.com/book/ru/v2/ch00/r_core_editor</a></p>
        
        <h3>Настройка ветки по умолчанию</h3>
        <p class="text">При инициализации репозитория командой <span class="intext">git init</span>, создаётся ветка с именем master по умолчанию.</p>
        <p class="text">Начиная с версии 2.28, можно задать другое имя для ветки по умолчанию:</p>
        <pre class="code">$ git config --global init.defaultBranch main</pre>
      
        <h3>Как получить помощь?</h3>
        <pre class="code">
$ git help [команда]
$ git [команда] --help
$ man git-[команда]</pre>
      
        <h2>Создание Git-репозитория</h2>
        <p class="text">Получить репозиторий Git можно двумя способами:
        превратить локальный каталог в репозиторий Git,
        либо клонировать существующий репозиторий из любого места.</p>
        <h3>Создание репозитория в существующем каталоге</h3>
        <p class="text">Перейти в каталог:</p>
        <pre class="code">$ cd /home/user/my_project</pre>
        <p class="text">а затем выполните команду:</p>
        <pre class="code">$ git init</pre>
        
        <h3>Клонирование существующего репозитория</h3>
        <p class="text">Клонирование репозитория осуществляется командой:</p>
        <pre class="code">git clone [url]</pre>
        <p class="text">Например, клонировать библиотеку libgit2:</p>
        <pre class="code">$ git clone https://github.com/libgit2/libgit2</pre>
        <p class="text">Эта команда создаёт каталог libgit2, инициализирует в нём подкаталог .git</p>
        <p class="text">Для клонирования в каталог с другим именем, указать имя, как параметр командной строки:</p>
        <pre class="code">$ git clone https://github.com/libgit2/libgit2 mylibgit</pre>
      
        <h2>Отслеживание новых файлов</h2>
        <p class="text">Для того чтобы начать отслеживать новый файл, используется команда <span class="intext">git add</span>.</p>
        <pre class="code">$ git add newfile</pre>
        
        <h2>Определение состояния</h2>
        <p class="text">Основной инструмент для определения состояния — команда <span class="intext">git status</span>.</p>
        <pre class="code">
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean</pre>
      </div>
      
      <div class="column">
        <h3>Просмотр индексированных и неиндексированных изменений</h3>
        <p class="text">Если результат работы команды git status недостаточно информативен для вас — вам хочется знать, что конкретно поменялось, а не только какие файлы были изменены — вы можете использовать команду git diff.


  Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить git diff --staged. Эта команда сравнивает ваши проиндексированные изменения с последним коммитом
  
  а так же git diff --cached для просмотра проиндексированных изменений (--staged и --cached синонимы):
  </p>






<h3>Коммит изменений</h3>
<p class="text">
  Теперь, когда ваш индекс находится в таком состоянии, как вам и хотелось, вы можете зафиксировать свои изменения. Запомните, всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые вами, и для которых вы не выполнили git add после редактирования — не войдут в этот коммит. Они останутся изменёнными файлами на вашем диске. В нашем случае, когда вы в последний раз выполняли git status, вы видели что всё проиндексировано, и вот, вы готовы к коммиту. Простейший способ зафиксировать изменения — это набрать git commit:
  
  $ git commit
  
  Эта команда откроет выбранный вами текстовый редактор.
  
  
  
  Есть и другой способ — вы можете набрать свой комментарий к коммиту в командной строке вместе с командой commit указав его после параметра -m, как в следующем примере:
  
  $ git commit -m "Story 182: fix benchmarks for speed"
  
  </p>

<h3>Удаление файлов</h3>

<p class="text">
  Для того чтобы удалить файл из Git, вам необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит. Это позволяет сделать команда git rm, которая также удаляет файл из вашего рабочего каталога, так что в следующий раз вы не увидите его как «неотслеживаемый».

Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра -f.

</p>


<h3>Просмотр истории коммитов</h3>
<p class="text">
  После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, вероятно вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда git log
  
  </p>


<h2>Операции отмены</h2>
<p class="text">
  
В любой момент вам может потребоваться что-либо отменить. Здесь мы рассмотрим несколько основных способов отмены сделанных изменений. Будьте осторожны, не все операции отмены в свою очередь можно отменить! Это одна из редких областей Git, где неверными действиями можно необратимо удалить результаты своей работы.

Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит — внесите необходимые изменения, добавьте их в индекс и сделайте коммит ещё раз, указав параметр --amend:

$ git commit --amend
Эта команда использует область подготовки (индекс) для внесения правок в коммит. Если вы ничего не меняли с момента последнего коммита (например, команда запущена сразу после предыдущего коммита), то снимок состояния останется в точности таким же, а всё что вы сможете изменить — это ваше сообщение к коммиту.

Запустится тот же редактор, только он уже будет содержать сообщение предыдущего коммита. Вы можете редактировать сообщение как обычно, однако, оно заменит сообщение предыдущего коммита.

Например, если вы сделали коммит и поняли, что забыли проиндексировать изменения в файле, который хотели добавить в коммит, то можно сделать следующее:

$ git commit -m 'Initial commit'
$ git add forgotten_file
$ git commit --amend
В итоге получится единый коммит — второй коммит заменит результаты первого

</p>

<h2>Работа с удалёнными репозиториями</h2>

<h3>Просмотр удалённых репозиториев</h3>
<p class="text">
  
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду <span class="intext">git remote</span>.
 Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin — имя по умолчанию,
  которое Git даёт серверу, с которого производилось клонирование:
</p>
<pre class="code">$ git remote
origin</pre>

<p class="text">Вы можете также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:</p>

<pre class="code">
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
</pre>


<h3>Добавление удалённых репозиториев</h3>

<p class="text">Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду <span class="intext">git remote add [shortname] [url]</span>:</p>

<pre class="code">
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)
</pre>


<h3>Получение изменений из удалённого репозитория</h3>
<p class="text">Для получения данных из удалённых проектов:</p>
<pre class="code">$ git fetch [remote-name]</pre>
<p class="text">
Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, git fetch origin извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы
</p>

<h3>Отправка изменений в удаленный репозиторий</h3>
<p class="text">
  Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий.
  Команда для этого действия простая: <span class="intext">git push [remote-name] [branch-name]</span>
  Чтобы отправить вашу ветку master на сервер origin 
  (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:
  </p>
<pre class="code">$ git push origin master</pre>
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а после него выполнить команду push попытаетесь вы, то ваш push точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push. Обратитесь к главе Ветвление в Git для более подробного описания, как отправлять изменения на удалённый сервер.
<p class="text"></p>


<h2>Управление ветками</h2>
<h3>Создание новой ветки</h3>
<pre class="code">$ git branch testing</pre>


<h3>Одновременное создание новой ветки и переключение на неё</h3>
<p class="text">
  Как правило, при создании новой ветки вы хотите сразу на неё переключиться — это можно сделать используя команду: <span class="intext">git checkout -b [newbranchname]</span>
</p>
<div class="note">
  <p class="text">Начиная с Git версии 2.23, можно использовать <span class="intext">git switch</span> вместо <span class="intext">git checkout</span>:</p>
  <p class="text">Переключиться на существующую ветку: <span class="intext">git switch testing-branch</span>.</p>
  <div class="text">Создать новую ветку и переключиться на нее: <span class="intext">git switch -create new-branch</span>.</div>
</div>

<h3>Переключение веток</h3>
<p class="text">Для переключения на существующую ветку выполните команду git checkout.</p>
<pre class="code">$ git checkout otherbranch</pre>



<h2>Основы слияния</h2>
<p class="text">Предположим, вы решили, что работа по проблеме #53 закончена и её можно влить в ветку master.
  Для этого нужно выполнить слияние ветки iss53 точно так же, как вы делали это с веткой hotfix ранее. 
  Все, что нужно сделать — переключиться на ветку, в которую вы хотите включить изменения, и выполнить команду git merge:</p>
<pre class="code">
$ git checkout master
Switched to branch 'master'
$ git merge iss53</pre>


      </div>
    </div>
  </div>
</body>
</html>